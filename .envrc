strict_env

mkdir -p local/direnv

IFS=$'\n' local files_to_watch=($(find . -name '*.nix' -o -name '*.cabal'))
local hashes=$(cat ${files_to_watch[@]} | md5sum | cut -c -32)
local cachedir="local/direnv/$hashes"

if [ ! -d "$cachedir" ]; then
    trap "rm -rf \"$cachedir\"" ERR

    # 1. Instantiate the full shell to obtain its shellHook and pin dependencies
    mkdir "$cachedir"
    nix-instantiate --add-root "$cachedir/shell.drv" --indirect shell.nix

    # 2. TODO: Some times only comments or whitespace changes. When the resulting derivation already
    # exists, stop early.

    # 3. Dump a pure nix-shell environment without having run shellHook, but store shellHook
    # so we can run it every time we enter the shell.
    # Notes:
    # - We can't just do text manipulation of shell.drv file to change shellHook
    #   because it becomes an invalid derivation due to inputs not having changed
    #   but outputs have.
    # - Removing shellHook entirely removes dependencies we might need.
    # - It seems, however, that Nix doesn't do dependency tracking properly if
    #   we nix-instantiate -E 'some-expression' for dependencies in the shellHook.
    # - Writing a new .nix file that does builtins.readFile modifiedShellHookFile.sh as
    #   the new shellHook also doesn't seem to catch dependencies properly. Is this
    #   some special behaviour where Nix does something special for interpolations
    #   when evaluating but is incapable of detecting store paths in shell hooks otherwise?
    # Conclusion: we can only tell users to explicitly include dependencies instead of referencing
    # them with interpolation in shell hooks!
    nix-store -qb shellHook "$cachedir/shell.drv" > "$cachedir/shellHook.sh"
    sed -e 's|^|# |' < "$cachedir/shellHook.sh" > "$cachedir/shellHookCommented.sh"
    echo "let shell = import ../../../shell.nix; in shell.overrideAttrs (_: { shellHook = builtins.readFile ./shellHookCommented.sh; })" > "$cachedir/shellNoHook.nix"

    # The following is a less complicated derivation than shell.nix and should never fail,
    # so we redirect stdout to /dev/null to avoid duplicated output
    nix-shell --pure --run "$direnv dump bash > $cachedir/direnv_bash_dump.sh" "$cachedir/shellNoHook.nix" > /dev/null
    rm "$cachedir/shellNoHook.nix" # Avoid extra nix files changing hashes
    trap - ERR
fi

# Source cached environment and treat some environment variables
# especially.
local user_path="${PATH:-}"
local user_xdg_data_dirs="${XDG_DATA_DIRS:-}"

source "$cachedir/direnv_bash_dump.sh"
source "$cachedir/shellHook.sh"

export PATH="$PATH:$user_path"
export XDG_DATA_DIRS="${XDG_DATA_DIRS:-}:$user_xdg_data_dirs"
export IN_NIX_SHELL="impure"

watch_file "${files_to_watch[@]}"
